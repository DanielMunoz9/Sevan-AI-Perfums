import { supabase } from './supabase'
import type { Product } from '@/types'

export class SupabaseService {
  private client = supabase

  // =================== PRODUCTOS ===================
  
  async getProducts(): Promise<Product[]> {
    try {
      const { data, error } = await this.client
        .from('products')
        .select(`
          *,
          categories (
            id,
            name,
            slug
          )
        `)
        .eq('is_active', true)
        .order('created_at', { ascending: false })

      if (error) {
        console.error('Error fetching products:', error)
        return []
      }
      
      return data?.map(this.transformProduct) || []
    } catch (error) {
      console.error('Error fetching products:', error)
      return []
    }
  }

  async getFeaturedProducts(): Promise<Product[]> {
    try {
      const { data, error } = await this.supabase
        .from('products')
        .select(`
          *,
          categories (
            id,
            name,
            slug
          )
        `)
        .eq('is_active', true)
        .eq('is_featured', true)
        .order('created_at', { ascending: false })
        .limit(8)

      if (error) throw error
      
      return data?.map(this.transformProduct) || []
    } catch (error) {
      console.error('Error fetching featured products:', error)
      return []
    }
  }

  async getProductBySlug(slug: string): Promise<Product | null> {
    try {
      const { data, error } = await this.supabase
        .from('products')
        .select(`
          *,
          categories (
            id,
            name,
            slug
          )
        `)
        .eq('slug', slug)
        .eq('is_active', true)
        .single()

      if (error) throw error
      
      return data ? this.transformProduct(data) : null
    } catch (error) {
      console.error('Error fetching product:', error)
      return null
    }
  }

  async createProduct(productData: Partial<Product>): Promise<Product | null> {
    try {
      const { data, error } = await this.supabase
        .from('products')
        .insert({
          sku: productData.slug || `SKU-${Date.now()}`,
          title: productData.name!,
          visible_title: productData.visible_title || productData.name!,
          slug: productData.slug!,
          short_description: productData.short_description,
          long_description: productData.description,
          price: productData.price!,
          sale_price: productData.sale_price,
          stock: productData.stock || 0,
          images: productData.images || [],
          scent_notes: productData.scent_notes || { top: [], heart: [], base: [] },
          tags: [],
          is_featured: productData.is_featured || false,
          is_active: true
        })
        .select()
        .single()

      if (error) throw error
      
      return data ? this.transformProduct(data) : null
    } catch (error) {
      console.error('Error creating product:', error)
      return null
    }
  }

  // =================== CARRITO ===================
  
  async getCartItems(userId?: string, sessionId?: string): Promise<CartItem[]> {
    try {
      let query = this.supabase
        .from('cart_items')
        .select(`
          *,
          products (
            id,
            title,
            visible_title,
            price,
            sale_price,
            images,
            stock
          )
        `)

      if (userId) {
        query = query.eq('user_id', userId)
      } else if (sessionId) {
        query = query.eq('session_id', sessionId)
      } else {
        return []
      }

      const { data, error } = await query

      if (error) throw error
      
      return data?.map(item => ({
        id: item.id,
        productId: item.product_id,
        quantity: item.quantity,
        addedAt: item.created_at,
        product: item.products ? this.transformProduct(item.products) : null
      })) || []
    } catch (error) {
      console.error('Error fetching cart items:', error)
      return []
    }
  }

  async addToCart(productId: string, quantity: number, userId?: string, sessionId?: string): Promise<boolean> {
    try {
      // Verificar si el item ya existe
      let existingQuery = this.supabase
        .from('cart_items')
        .select('*')
        .eq('product_id', productId)

      if (userId) {
        existingQuery = existingQuery.eq('user_id', userId)
      } else if (sessionId) {
        existingQuery = existingQuery.eq('session_id', sessionId)
      }

      const { data: existing } = await existingQuery.single()

      if (existing) {
        // Actualizar cantidad
        const { error } = await this.supabase
          .from('cart_items')
          .update({ 
            quantity: existing.quantity + quantity,
            updated_at: new Date().toISOString()
          })
          .eq('id', existing.id)

        if (error) throw error
      } else {
        // Crear nuevo item
        const { error } = await this.supabase
          .from('cart_items')
          .insert({
            product_id: productId,
            quantity,
            user_id: userId || null,
            session_id: sessionId || null
          })

        if (error) throw error
      }

      return true
    } catch (error) {
      console.error('Error adding to cart:', error)
      return false
    }
  }

  async updateCartItem(itemId: string, quantity: number): Promise<boolean> {
    try {
      if (quantity <= 0) {
        return this.removeFromCart(itemId)
      }

      const { error } = await this.supabase
        .from('cart_items')
        .update({ 
          quantity,
          updated_at: new Date().toISOString()
        })
        .eq('id', itemId)

      if (error) throw error
      return true
    } catch (error) {
      console.error('Error updating cart item:', error)
      return false
    }
  }

  async removeFromCart(itemId: string): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from('cart_items')
        .delete()
        .eq('id', itemId)

      if (error) throw error
      return true
    } catch (error) {
      console.error('Error removing from cart:', error)
      return false
    }
  }

  async clearCart(userId?: string, sessionId?: string): Promise<boolean> {
    try {
      let query = this.supabase.from('cart_items').delete()

      if (userId) {
        query = query.eq('user_id', userId)
      } else if (sessionId) {
        query = query.eq('session_id', sessionId)
      }

      const { error } = await query

      if (error) throw error
      return true
    } catch (error) {
      console.error('Error clearing cart:', error)
      return false
    }
  }

  // =================== ÓRDENES ===================
  
  async createOrder(orderData: CreateOrderRequest): Promise<Order | null> {
    try {
      const orderNumber = await this.generateOrderNumber()
      
      const { data, error } = await this.supabase
        .from('orders')
        .insert({
          order_number: orderNumber,
          user_id: orderData.userId || null,
          subtotal: orderData.subtotal,
          tax_amount: orderData.taxAmount || 0,
          shipping_amount: orderData.shippingAmount || 0,
          total_amount: orderData.totalAmount,
          billing_address: orderData.billingAddress,
          shipping_address: orderData.shippingAddress,
          payment_method: orderData.paymentMethod,
          status: 'pending',
          payment_status: 'pending'
        })
        .select()
        .single()

      if (error) throw error

      // Crear items de la orden
      for (const item of orderData.items) {
        await this.supabase
          .from('order_items')
          .insert({
            order_id: data.id,
            product_id: item.productId,
            sku: item.sku,
            title: item.title,
            quantity: item.quantity,
            unit_price: item.unitPrice,
            total_price: item.totalPrice
          })
      }

      return this.transformOrder(data)
    } catch (error) {
      console.error('Error creating order:', error)
      return null
    }
  }

  async getOrderById(orderId: string): Promise<Order | null> {
    try {
      const { data, error } = await this.supabase
        .from('orders')
        .select(`
          *,
          order_items (
            *,
            products (
              title,
              images
            )
          )
        `)
        .eq('id', orderId)
        .single()

      if (error) throw error
      
      return data ? this.transformOrder(data) : null
    } catch (error) {
      console.error('Error fetching order:', error)
      return null
    }
  }

  // =================== UTILIDADES ===================

  private transformProduct(data: any): Product {
    return {
      id: parseInt(data.id) || Date.now(),
      name: data.title,
      visible_title: data.visible_title,
      description: data.long_description || data.short_description || '',
      short_description: data.short_description || '',
      price: data.price,
      sale_price: data.sale_price || undefined,
      image_url: data.images?.[0] || '/images/placeholder-product.svg',
      images: data.images || [],
      brand: 'SEVÁN PERFUM',
      category: data.categories?.name || 'General',
      created_at: data.created_at,
      scent_family: 'Artesanal',
      scent_notes: data.scent_notes || { top: [], middle: [], base: [] },
      genre: data.categories?.name === 'Hombre' ? 'Masculino' : 
             data.categories?.name === 'Mujer' ? 'Femenino' : 'Unisex',
      concentration: '18%',
      stock: data.stock || 0,
      slug: data.slug,
      is_featured: data.is_featured || false,
      avg_rating: 4.5,
      review_count: 0,
      sales: 0
    }
  }

  private transformOrder(data: any): Order {
    return {
      id: parseInt(data.id) || Date.now(),
      orderNumber: data.order_number,
      status: data.status,
      paymentStatus: data.payment_status,
      subtotal: data.subtotal,
      shipping: data.shipping_amount,
      total: data.total_amount,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
      items: data.order_items?.map((item: any) => ({
        id: item.id,
        productId: item.product_id,
        sku: item.sku,
        title: item.title,
        quantity: item.quantity,
        unitPrice: item.unit_price,
        totalPrice: item.total_price
      })) || [],
      billingAddress: data.billing_address,
      shippingAddress: data.shipping_address
    }
  }

  private async generateOrderNumber(): Promise<string> {
    const { data } = await this.supabase.rpc('generate_order_number')
    return data || `SV${Date.now()}`
  }
}

// =================== TIPOS ===================

export interface CartItem {
  id: string
  productId: string
  quantity: number
  addedAt: string
  product?: Product | null
}

export interface CreateOrderRequest {
  userId?: string
  items: {
    productId: string
    sku: string
    title: string
    quantity: number
    unitPrice: number
    totalPrice: number
  }[]
  subtotal: number
  taxAmount?: number
  shippingAmount?: number
  totalAmount: number
  billingAddress: any
  shippingAddress: any
  paymentMethod: string
}

export interface Order {
  id: number
  orderNumber: string
  status: string
  paymentStatus: string
  subtotal: number
  shipping: number
  total: number
  createdAt: string
  updatedAt: string
  items: any[]
  billingAddress: any
  shippingAddress: any
}

// Instancia singleton
export const supabaseService = new SupabaseService()